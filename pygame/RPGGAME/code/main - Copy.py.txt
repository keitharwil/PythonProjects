import pygame
import sys
from pathlib import Path
from spritesheet import Spritesheet
from os.path import join

pygame.init()

# Constants
WINDOW_WIDTH, WINDOW_HEIGHT = 1920, 1080
FPS = 60
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (100, 100, 100)
LIGHT_GRAY = (200, 200, 200)
RED = (220, 50, 50)
GREEN = (50, 220, 50)
BLUE = (50, 150, 220)
YELLOW = (255, 215, 0)

# Game states
STATE_VISUAL_NOVEL = "visual_novel"
STATE_BATTLE = "battle"
STATE_MENU = "menu"

class SpriteSheetAnimations:
    def __init__(self, spritesheet_path):
        # Initialize spritesheet with 80x64 sprite size
        self.sheet = Spritesheet(
            filepath=Path(join("assets", "WarriorMan-Sheet.png")),
            sprite_size=(80, 64),
            spacing=(0, 0),
            scale=(256, 256)  # Scale to 4x size
        )
        self.animations = self.parse_spritesheet()
    
    def parse_spritesheet(self):
        # Define animations with their row and frame count
        animations = {}
        
        # Walking animations (8 frames each)
        animations['walk_down'] = self.sheet.get_sprites([(0, i) for i in range(8)])
        animations['walk_left'] = self.sheet.get_sprites([(1, i) for i in range(8)])
        animations['walk_right'] = self.sheet.get_sprites([(2, i) for i in range(8)])
        animations['walk_up'] = self.sheet.get_sprites([(3, i) for i in range(8)])
        
        # Attack animations
        animations['attack_down'] = self.sheet.get_sprites([(11, i) for i in range(8)])
        animations['attack_left'] = self.sheet.get_sprites([(5, i) for i in range(6)])
        animations['attack_right'] = self.sheet.get_sprites([(6, i) for i in range(5)])
        animations['attack_up'] = self.sheet.get_sprites([(7, i) for i in range(5)])
        
        # Cast spell animations
        animations['cast_down'] = self.sheet.get_sprites([(8, i) for i in range(10)])
        animations['cast_left'] = self.sheet.get_sprites([(9, i) for i in range(7)])
        animations['cast_right'] = self.sheet.get_sprites([(10, i) for i in range(5)])
        animations['cast_up'] = self.sheet.get_sprites([(11, i) for i in range(8)])
        
        # Death animation
        animations['death'] = self.sheet.get_sprites([(12, i) for i in range(13)])
        
        # Idle animations (first frame of walk)
        animations['idle_down'] = [animations['walk_down'][0]]
        animations['idle_left'] = [animations['walk_left'][0]]
        animations['idle_right'] = [animations['walk_right'][0]]
        animations['idle_up'] = [animations['walk_up'][0]]
        
        return animations

class AnimatedSprite:
    def __init__(self, spritesheet, x, y):
        self.spritesheet = spritesheet
        self.x = x
        self.y = y
        self.current_animation = 'idle_down'
        self.frame_index = 0
        self.animation_speed = 0.05
        self.animation_timer = 0
        self.loop = True
        self.animation_finished = False
    
    def set_animation(self, animation_name, loop=True):
        if self.current_animation != animation_name:
            self.current_animation = animation_name
            self.frame_index = 0
            self.animation_timer = 0
            self.loop = loop
            self.animation_finished = False
    
    def update(self, dt):
        if self.spritesheet and self.spritesheet.animations:
            self.animation_timer += dt
            
            if self.animation_timer >= self.animation_speed:
                self.animation_timer = 0
                frames = self.spritesheet.animations[self.current_animation]
                
                if self.frame_index < len(frames) - 1:
                    self.frame_index += 1
                elif self.loop:
                    self.frame_index = 0
                else:
                    self.animation_finished = True
    
    def draw(self, surface):
        if self.spritesheet and self.spritesheet.animations:
            frames = self.spritesheet.animations[self.current_animation]
            if frames:
                frame = frames[int(self.frame_index)]
                surface.blit(frame, (self.x, self.y))
        else:
            # Fallback if no spritesheet
            pygame.draw.circle(surface, GREEN, (int(self.x + 32), int(self.y + 32)), 30)

class Character:
    def __init__(self, name, hp, max_hp, atk, defense, sprite=None):
        self.name = name
        self.hp = hp
        self.max_hp = max_hp
        self.atk = atk
        self.defense = defense
        self.is_alive = True
        self.sprite = sprite
    
    def take_damage(self, damage):
        actual_damage = max(1, damage - self.defense)
        self.hp = max(0, self.hp - actual_damage)
        if self.hp == 0:
            self.is_alive = False
        return actual_damage
    
    def heal(self, amount):
        self.hp = min(self.max_hp, self.hp + amount)

class VisualNovelScene:
    def __init__(self, text, character_name, next_scene=None, choices=None):
        self.text = text
        self.character_name = character_name
        self.next_scene = next_scene
        self.choices = choices or []
        self.current_char = 0
        self.text_speed = 2
        self.full_text_shown = False
    
    def update(self):
        if not self.full_text_shown:
            self.current_char = min(len(self.text), self.current_char + self.text_speed)
            if self.current_char >= len(self.text):
                self.full_text_shown = True
    
    def get_displayed_text(self):
        return self.text[:self.current_char]
    
    def skip_text(self):
        self.current_char = len(self.text)
        self.full_text_shown = True

class Game:
    def __init__(self):
        self.screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
        self.screen_width = self.screen.get_width()
        self.screen_height = self.screen.get_height()
        pygame.display.set_caption("Visual Novel JRPG")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(None, 32)
        self.small_font = pygame.font.Font(None, 24)
        self.state = STATE_VISUAL_NOVEL
        
        # Load spritesheet (replace with your file path)
        self.player_spritesheet = SpriteSheetAnimations('character_spritesheet.png')
        
        # Load backgrounds (optional - set to None to use solid colors)
        try:
            self.vn_background = pygame.image.load('vn_background.png').convert()
            self.vn_background = pygame.transform.scale(self.vn_background, (self.screen_width, self.screen_height))
        except:
            self.vn_background = None
        
        try:
            self.battle_background = pygame.image.load('battle_background.png').convert()
            self.battle_background = pygame.transform.scale(self.battle_background, (self.screen_width, self.screen_height))
        except:
            self.battle_background = None
        
        # Initialize scenes
        self.init_scenes()
        self.current_scene_key = "intro"
        
        # Battle system
        player_sprite = AnimatedSprite(self.player_spritesheet, 100, 150)
        self.player = Character("Hero", 100, 100, 25, 5, sprite=player_sprite)
        self.enemy = None
        self.battle_menu_index = 0
        self.battle_log = []
        self.battle_phase = "player_turn"
        self.battle_animation_playing = False
        
        # Screen effects
        self.screen_shake_duration = 0
        self.screen_shake_intensity = 0
        self.red_flash_alpha = 0
        
    def init_scenes(self):
        self.scenes = {
            "intro": VisualNovelScene(
                "Welcome, brave hero! The kingdom is in danger. Will you help us?",
                "Elder",
                choices=[
                    ("Yes, I will help!", "accept"),
                    ("Tell me more first", "more_info")
                ]
            ),
            "accept": VisualNovelScene(
                "Excellent! A monster has been spotted nearby. Prepare for battle!",
                "Elder",
                next_scene="battle_start"
            ),
            "more_info": VisualNovelScene(
                "Dark forces have awakened. Only you can stop them!",
                "Elder",
                choices=[
                    ("I'm ready to fight!", "accept"),
                    ("I need to think about it", "intro")
                ]
            ),
            "battle_start": VisualNovelScene(
                "A wild Goblin appears! Get ready to fight!",
                "System",
                next_scene="enter_battle"
            ),
            "victory": VisualNovelScene(
                "You defeated the monster! The village is safe... for now.",
                "Elder",
                next_scene="intro"
            ),
            "defeat": VisualNovelScene(
                "You have been defeated... Try again, hero!",
                "System",
                next_scene="intro"
            )
        }
    
    def start_battle(self):
        self.state = STATE_BATTLE
        player_sprite = AnimatedSprite(self.player_spritesheet, self.screen_width // 4, self.screen_height // 2)
        enemy_sprite = AnimatedSprite(self.player_spritesheet, 3 * self.screen_width // 4, self.screen_height // 2)
        self.enemy = Character("Goblin", 60, 60, 15, 3, sprite=enemy_sprite)
        self.player.hp = self.player.max_hp
        self.player.sprite.set_animation('idle_down')
        self.battle_menu_index = 0
        self.battle_log = ["Battle started!"]
        self.battle_phase = "player_turn"
        self.battle_animation_playing = False
        self.screen_shake_duration = 0
        self.screen_shake_intensity = 0
        self.red_flash_alpha = 0
    
    def add_screen_shake(self, duration, intensity):
        """Add screen shake effect."""
        self.screen_shake_duration = duration
        self.screen_shake_intensity = intensity
    
    def add_red_flash(self, alpha):
        """Add red flash effect."""
        self.red_flash_alpha = alpha
    
    def update_screen_effects(self, dt):
        """Update screen shake and flash effects."""
        # Update screen shake
        if self.screen_shake_duration > 0:
            self.screen_shake_duration -= dt
            if self.screen_shake_duration < 0:
                self.screen_shake_duration = 0
        
        # Update red flash
        if self.red_flash_alpha > 0:
            self.red_flash_alpha -= dt * 400  # Fade out speed
            if self.red_flash_alpha < 0:
                self.red_flash_alpha = 0
    
    def get_screen_shake_offset(self):
        """Get current screen shake offset."""
        if self.screen_shake_duration > 0:
            import random
            offset_x = random.randint(-self.screen_shake_intensity, self.screen_shake_intensity)
            offset_y = random.randint(-self.screen_shake_intensity, self.screen_shake_intensity)
            return offset_x, offset_y
        return 0, 0
    
    def draw_text_box(self, text, x, y, width, height):
        bg_surface = pygame.Surface((width, height))
        bg_surface.set_alpha(50)  # Transparency level (0-255)
        bg_surface.fill(BLACK)     # Color of the background

        self.screen.blit(bg_surface, (x, y))


        pygame.draw.rect(self.screen, WHITE, (x, y, width, height), 3)
        
        words = text.split(' ')
        lines = []
        current_line = []
        
        for word in words:
            test_line = ' '.join(current_line + [word])
            if self.small_font.size(test_line)[0] < width - 20:
                current_line.append(word)
            else:
                if current_line:
                    lines.append(' '.join(current_line))
                current_line = [word]
        if current_line:
            lines.append(' '.join(current_line))
        
        for i, line in enumerate(lines[:4]):
            text_surf = self.small_font.render(line, True, WHITE)
            self.screen.blit(text_surf, (x + 10, y + 10 + i * 30))
    
    def draw_visual_novel(self):
        # Draw background
        if self.vn_background:
            self.screen.blit(self.vn_background, (0, 0))
        else:
            self.screen.fill((40, 30, 60))  # Fallback color
        
        scene = self.scenes[self.current_scene_key]
        scene.update()
        
        # Create dialogue box rect and position at midbottom
        dialogue_rect = pygame.Rect(0, 0, 700, 150)
        dialogue_rect.midbottom = (self.screen_width // 2, self.screen_height - 10)
        
        # Create name box rect and position above dialogue box
        name_rect = pygame.Rect(0, 0, 200, 40)
        name_rect.bottomleft = (dialogue_rect.left, dialogue_rect.top - 10)
        
        # Draw character name box
        pygame.draw.rect(self.screen, BLUE, name_rect)
        name_text = self.font.render(scene.character_name, True, WHITE)
        name_text_rect = name_text.get_rect(center=name_rect.center)
        self.screen.blit(name_text, name_text_rect)
        
        # Draw dialogue box
        self.draw_text_box(scene.get_displayed_text(), dialogue_rect.x, dialogue_rect.y, dialogue_rect.width, dialogue_rect.height)
        
        # Draw choices if available and text is fully shown
        if scene.choices and scene.full_text_shown:
            choice_width = 400
            choice_height = 50
            choice_spacing = 10
            start_y = self.screen_height // 3
            
            for i, (choice_text, _) in enumerate(scene.choices):
                choice_rect = pygame.Rect(0, 0, choice_width, choice_height)
                choice_rect.midtop = (self.screen_width // 2, start_y + i * (choice_height + choice_spacing))
                
                color = YELLOW if i == self.battle_menu_index else WHITE
                pygame.draw.rect(self.screen, GRAY, choice_rect)
                pygame.draw.rect(self.screen, color, choice_rect, 3)
                
                choice_surf = self.small_font.render(choice_text, True, color)
                choice_text_rect = choice_surf.get_rect(center=choice_rect.center)
                self.screen.blit(choice_surf, choice_text_rect)
        
        # Draw continue prompt
        if scene.full_text_shown and not scene.choices:
            prompt = self.small_font.render("Press SPACE to continue", True, YELLOW)
            prompt_rect = prompt.get_rect(bottomright=(self.screen_width - 20, self.screen_height - 20))
            self.screen.blit(prompt, prompt_rect)
    
    def draw_battle(self):
        # Get screen shake offset
        shake_x, shake_y = self.get_screen_shake_offset()
        
        # Create a temporary surface for shaking
        temp_surface = pygame.Surface((self.screen_width, self.screen_height))
        
        # Draw background
        if self.battle_background:
            temp_surface.blit(self.battle_background, (0, 0))
        else:
            temp_surface.fill((60, 40, 40))  # Fallback color
        
        # Update and draw sprites
        dt = self.clock.get_time() / 1000.0
        self.update_screen_effects(dt)
        
        if self.player.sprite:
            self.player.sprite.update(dt)
            self.player.sprite.draw(temp_surface)
            
            # Check if attack animation finished
            if self.battle_animation_playing and self.player.sprite.animation_finished:
                self.battle_animation_playing = False
                self.player.sprite.set_animation('idle_down')
        
        if self.enemy and self.enemy.sprite:
            self.enemy.sprite.update(dt)
            self.enemy.sprite.draw(temp_surface)
        
        # Create stat boxes with anchor positioning
        player_stats_rect = pygame.Rect(0, 0, 200, 120)
        player_stats_rect.bottomleft = (100, self.screen_height - 180)
        
        enemy_stats_rect = pygame.Rect(0, 0, 200, 120)
        enemy_stats_rect.bottomright = (self.screen_width - 100, self.screen_height - 180)
        
        # Draw player stats
        self.draw_character_stats_on_surface(temp_surface, self.player, player_stats_rect.x, player_stats_rect.y, True)
        
        # Draw enemy stats
        self.draw_character_stats_on_surface(temp_surface, self.enemy, enemy_stats_rect.x, enemy_stats_rect.y, False)
        
        # Draw battle menu (bottom left)
        if self.battle_phase == "player_turn" and not self.battle_animation_playing:
            menu_options = ["Attack", "Magic", "Heal"]
            menu_width = 200
            menu_height = 40
            menu_spacing = 5
            
            for i, option in enumerate(menu_options):
                menu_rect = pygame.Rect(0, 0, menu_width, menu_height)
                menu_rect.bottomleft = (100, self.screen_height - 20 - (len(menu_options) - 1 - i) * (menu_height + menu_spacing))
                
                color = YELLOW if i == self.battle_menu_index else WHITE
                pygame.draw.rect(temp_surface, GRAY, menu_rect)
                pygame.draw.rect(temp_surface, color, menu_rect, 3)
                
                text = self.small_font.render(option, True, color)
                text_rect = text.get_rect(center=menu_rect.center)
                temp_surface.blit(text, text_rect)
        
        # Draw battle log (center bottom)
        log_width = 500
        log_height = 150
        log_rect = pygame.Rect(0, 0, log_width, log_height)
        log_rect.midbottom = (self.screen_width // 2, self.screen_height - 20)
        
        pygame.draw.rect(temp_surface, BLACK, log_rect)
        pygame.draw.rect(temp_surface, WHITE, log_rect, 2)
        
        for i, log in enumerate(self.battle_log[-5:]):
            log_text = self.small_font.render(log, True, WHITE)
            temp_surface.blit(log_text, (log_rect.x + 10, log_rect.y + 10 + i * 28))
        
        # Blit temp surface to screen with shake offset
        self.screen.blit(temp_surface, (shake_x, shake_y))
        
        # Draw red flash overlay
        if self.red_flash_alpha > 0:
            flash_surface = pygame.Surface((self.screen_width, self.screen_height))
            flash_surface.set_alpha(int(self.red_flash_alpha))
            flash_surface.fill(RED)
            self.screen.blit(flash_surface, (0, 0))
    
    def draw_character_stats_on_surface(self, surface, char, x, y, is_player):
        # Character box
        color = GREEN if is_player else RED
        pygame.draw.rect(surface, color, (x, y, 200, 120), 3)
        
        # Name
        name_text = self.font.render(char.name, True, WHITE)
        surface.blit(name_text, (x + 10, y + 10))
        
        # HP bar
        hp_ratio = char.hp / char.max_hp
        pygame.draw.rect(surface, GRAY, (x + 10, y + 50, 180, 20))
        pygame.draw.rect(surface, GREEN, (x + 10, y + 50, int(180 * hp_ratio), 20))
        hp_text = self.small_font.render(f"HP: {char.hp}/{char.max_hp}", True, WHITE)
        surface.blit(hp_text, (x + 10, y + 80))
    
    def handle_visual_novel_input(self, event):
        scene = self.scenes[self.current_scene_key]
        
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_SPACE:
                if not scene.full_text_shown:
                    scene.skip_text()
                elif scene.choices:
                    pass
                elif scene.next_scene:
                    if scene.next_scene == "enter_battle":
                        self.start_battle()
                    else:
                        self.current_scene_key = scene.next_scene
                        self.scenes[self.current_scene_key].current_char = 0
                        self.scenes[self.current_scene_key].full_text_shown = False
            
            elif scene.choices and scene.full_text_shown:
                if event.key == pygame.K_UP:
                    self.battle_menu_index = (self.battle_menu_index - 1) % len(scene.choices)
                elif event.key == pygame.K_DOWN:
                    self.battle_menu_index = (self.battle_menu_index + 1) % len(scene.choices)
                elif event.key == pygame.K_z:
                    _, next_scene = scene.choices[self.battle_menu_index]
                    self.current_scene_key = next_scene
                    self.scenes[self.current_scene_key].current_char = 0
                    self.scenes[self.current_scene_key].full_text_shown = False
                    self.battle_menu_index = 0
    
    def handle_battle_input(self, event):
        if event.type == pygame.KEYDOWN and self.battle_phase == "player_turn" and not self.battle_animation_playing:
            if event.key == pygame.K_UP:
                self.battle_menu_index = (self.battle_menu_index - 1) % 3
            elif event.key == pygame.K_DOWN:
                self.battle_menu_index = (self.battle_menu_index + 1) % 3
            elif event.key == pygame.K_RETURN:
                self.execute_battle_action()
    
    def execute_battle_action(self):
        self.battle_animation_playing = True
        
        if self.battle_menu_index == 0:  # Attack
            self.player.sprite.set_animation('attack_down', loop=False)
            damage = self.enemy.take_damage(self.player.atk)
            self.battle_log.append(f"{self.player.name} attacks for {damage} damage!")
            # Add screen shake and red flash
            self.add_screen_shake(0.3, 8)  # 0.3 seconds, intensity 8
            self.add_red_flash(100)  # Alpha value 100
        elif self.battle_menu_index == 1:  # Magic
            self.player.sprite.set_animation('cast_down', loop=False)
            damage = self.enemy.take_damage(self.player.atk + 10)
            self.battle_log.append(f"{self.player.name} casts magic for {damage} damage!")
            # Stronger effects for magic
            self.add_screen_shake(0.4, 12)
            self.add_red_flash(150)
        elif self.battle_menu_index == 2:  # Heal
            self.player.sprite.set_animation('cast_down', loop=False)
            heal_amount = 20
            self.player.heal(heal_amount)
            self.battle_log.append(f"{self.player.name} heals for {heal_amount} HP!")
        
        if not self.enemy.is_alive:
            self.battle_log.append(f"{self.enemy.name} defeated!")
            pygame.time.set_timer(pygame.USEREVENT + 2, 1500, 1)
            return
        
        pygame.time.set_timer(pygame.USEREVENT + 1, 1500, 1)
    
    def enemy_turn(self):
        self.battle_phase = "enemy_turn"
        if self.enemy.sprite:
            self.enemy.sprite.set_animation('attack_down', loop=False)
        
        damage = self.player.take_damage(self.enemy.atk)
        self.battle_log.append(f"{self.enemy.name} attacks for {damage} damage!")
        
        # Add screen shake and red flash for enemy attack
        self.add_screen_shake(0.3, 8)
        self.add_red_flash(100)
        
        if not self.player.is_alive:
            self.battle_log.append("You have been defeated!")
            pygame.time.set_timer(pygame.USEREVENT + 2, 1500, 1)
            return
        
        self.battle_phase = "player_turn"
    
    def end_battle(self, victory):
        pygame.time.set_timer(pygame.USEREVENT + 1, 0)
        pygame.time.set_timer(pygame.USEREVENT + 2, 0)
        if victory:
            self.current_scene_key = "victory"
        else:
            self.current_scene_key = "defeat"
        self.scenes[self.current_scene_key].current_char = 0
        self.scenes[self.current_scene_key].full_text_shown = False
        self.state = STATE_VISUAL_NOVEL
        self.player.is_alive = True
    
    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.USEREVENT + 1:
                    self.enemy_turn()
                elif event.type == pygame.USEREVENT + 2:
                    victory = not self.player.is_alive == False
                    self.end_battle(victory)
                elif self.state == STATE_VISUAL_NOVEL:
                    self.handle_visual_novel_input(event)
                elif self.state == STATE_BATTLE:
                    self.handle_battle_input(event)
            
            if self.state == STATE_VISUAL_NOVEL:
                self.draw_visual_novel()
            elif self.state == STATE_BATTLE:
                self.draw_battle()
            
            pygame.display.flip()
            self.clock.tick(FPS)
        
        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()